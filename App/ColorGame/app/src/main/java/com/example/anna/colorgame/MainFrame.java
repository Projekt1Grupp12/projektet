package com.example.anna.colorgame;import android.content.Context;import android.graphics.Rect;import android.os.Bundle;import android.text.InputFilter;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.inputmethod.InputMethodManager;import android.widget.AdapterView;import android.widget.AdapterView.OnItemSelectedListener;import android.widget.ArrayAdapter;import android.widget.Button;import android.widget.EditText;import android.widget.Spinner;import java.io.BufferedReader;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.DataInputStream;import java.io.DataOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.UnsupportedEncodingException;import java.util.ArrayList;import java.util.HashSet;import java.util.Set;/** * This class is an activity that is a Login window for the application. * It has two EditText fields for IP-address and Username, a spinner with drop down menu where user * can select an IP-address from the list, and a "Login" button. If any of the EditText fields is of * incorrect format pushing button will trigger an AlertDialog to show information regarding * incorrect input. IP-address is validated when EditText field loses focus and if it is of * incorrect format an alert icon pops up on the right side of the EditText. * If everything is correct, pushing "Login" button will start an AsyncTask that sends data to server. * Response from server, that is User ID will be stored in a player instance. Next an Intent is * created to start next activity and send player instance to it. */public class MainFrame extends SuperActivity {    private static final String TAG = "debugFrame";    //private String[] ipAddresses = {"Choose IP from the list.", "10.2.30.175", "10.2.19.28", "10.2.28.40"};    private ArrayList<String> ipAddresses = new ArrayList<String>();    private Button loginButton = null;    private EditText editIPText = null;    private EditText editNameText = null;    private Context context;    private boolean correctIPInput = false;    private File file;    private String FILENAME;    private Set<String> set;    private FileOutputStream fos;    /**     * It is used to get result, UserID in this case, from AsyncTask and store it in player instance.     * Different actions are taken depending on result parameter.     */    private AsyncResponse delegate = new AsyncResponse() {        @Override        public void postResult(String result) {            Log.d(TAG, "RESULTAT FRÃ…N SERVER " + result);            if (result.contains("SocketTimeoutException")) {                setAlertDialog(new AlertDialogClass(context, "Connection failed", "Connection to game server failed", ""));                getAlertDialog().ButtonOK();                loginButton.setEnabled(true);            } else if (!result.isEmpty()) {                ipAddresses.add(editIPText.getText().toString());                try {                    // write to byte array                    ByteArrayOutputStream baos = new ByteArrayOutputStream();                    DataOutputStream out = new DataOutputStream(baos);                    for (String element : ipAddresses) {                        out.writeUTF(element);                    }                    byte[] bytes = baos.toByteArray();                    fos = openFileOutput("IPfile", Context.MODE_PRIVATE);                    fos.write(bytes);                    fos.close();                } catch (FileNotFoundException e) {                    e.printStackTrace();                } catch (IOException e) {                    e.printStackTrace();                }                Log.d(TAG, "editIPText.getText()" + editIPText.getText().toString());                getPlayer().setUserID(result);                startNextActivity(getPlayer(), context, MainMenu.class);            } else {                setAlertDialog(new AlertDialogClass(context, "No userID", "You do not exist, please try again.", ""));                getAlertDialog().ButtonOK();            }        }    };    /**     * In this onCreate method context variable is instantiated, it is used in postResult() method.     * Button and EditText's variables are instantiated to be used further in the code.     * editNameText field is set to have max length of 20 characters.     * Listener: editIPText gets an onFocusChangeListener and the method of this listener is called     * whenever editIPText gets or loses focus. Every time state of focus change it validates input     * in editIPText.     * Spinner: spinner is added to activity to make it easier for user to fill ip-address. Spinner     * has a dropdown list with different IP's that can be selected.     *     * @param savedInstanceState     */    @Override    protected void onCreate(Bundle savedInstanceState) {        super.onCreate(savedInstanceState);        setContentView(R.layout.activity_main_frame);        Log.d(TAG, "onCreate()");        context = this;        file = context.getCacheDir();        FILENAME = "IPfile";        this.loginButton = (Button) findViewById(R.id.loginButton);        this.editNameText = (EditText) findViewById(R.id.editNameText);        this.editIPText = (EditText) findViewById(R.id.editIPText);        editNameText.setFilters(new InputFilter[]{                new InputFilter.LengthFilter(20)        });        ipAddresses.add("Choose IP from the list.");        String file = read_file(this, FILENAME);        Log.d(TAG, "file: " + file);        //set  = new HashSet<String>();        //set.addAll(ipAddresses);       //ipAddresses.addAll(set);        /*if ((savedInstanceState != null)                    && (savedInstanceState.getSerializable("ipaddresses") != null)) {                        Log.d(TAG, "Loading onSaveInstanceState");                        ipAddresses = (ArrayList<String>) savedInstanceState                             .getSerializable("ipaddresses");                 }*/        //This listener is called when focus state of editIPText is changed.        editIPText.setOnFocusChangeListener(new View.OnFocusChangeListener() {            @Override            public void onFocusChange(View view, boolean hasFocus) {                editIPText.setError(null);                correctIPInput = validateIP(editIPText.getText().toString());                if (!hasFocus) {                    Log.d(TAG, "When editIPText loses focus, validate ip");                    if (!correctIPInput) {                        editIPText.setError("Input is incorrect");                    }                }            }        });        //Spinner code here        final Spinner dynamicSpinner = (Spinner) findViewById(R.id.spinner);        ArrayAdapter<String> adapter = new ArrayAdapter<>(this, R.layout.my_spinner, ipAddresses);        adapter.setDropDownViewResource(R.layout.my_spinner_dropdown);        dynamicSpinner.setAdapter(adapter);        dynamicSpinner.setOnItemSelectedListener(new OnItemSelectedListener() {            @Override            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {                Log.d(TAG, "selection" + parent.getItemAtPosition(position));                selectionMade(dynamicSpinner, position);            }            @Override            public void onNothingSelected(AdapterView<?> adapterView) {            }        });    }    @Override    protected void onSaveInstanceState(Bundle state) {        state.putSerializable("ipaddresses", ipAddresses);        Log.d(TAG, "Saving onSaveInstanceState");        super.onSaveInstanceState(state);    }    /**     * This method is called when the button is clicked.     * upadateIPName method is called to store input from user as data in variables.     * Next we send data to server to get back userID.     *     * @param view View     */    public void login(View view) {//Button        Log.d(TAG, "Login button ");        loginButton.requestFocus();        boolean correctNameInput = validateName(editNameText.getText().toString());        setPlayerIPName();        if (correctIPInput && correctNameInput) {            loginButton.setEnabled(false);            sendDataToServer("" + getPlayer().getName(), getPlayer(), this.delegate);        } else {            if (!correctIPInput && !correctNameInput) {                setAlertDialog(new AlertDialogClass(this, "Error", "IP-adress and username are incorrect.", " "));            } else if (!correctIPInput) {                setAlertDialog(new AlertDialogClass(this, "Error", "IP-adress is incorrect.", " "));            } else if (!correctNameInput) {                setAlertDialog(new AlertDialogClass(this, "Error", "Username is empty.", " "));            }            getAlertDialog().ButtonOK();        }    }    /**     * This method updates ip and name variables with user input.     */    private void setPlayerIPName() {        Log.d(TAG, "Set Players IP and Name");        getPlayer().setChoosenIP(editIPText.getText().toString());        getPlayer().setName(editNameText.getText().toString());    }    @Override    public boolean dispatchTouchEvent(MotionEvent ev) {        //Log.d(TAG, "inside dispatchTouchEvent");        boolean handleReturn = super.dispatchTouchEvent(ev);        View view = getCurrentFocus();        int x = (int) ev.getX();        int y = (int) ev.getY();        if (view instanceof EditText) {            View innerView = getCurrentFocus();            // Log.d(TAG, "view instanceof EditText");            if (ev.getAction() == MotionEvent.ACTION_UP &&                    !getLocationOnScreen((EditText) innerView).contains(x, y)) {                // Log.d(TAG, "ev.getAction() == MotionEvent.ACTION_UP");                InputMethodManager input = (InputMethodManager)                        getSystemService(MainFrame.this.INPUT_METHOD_SERVICE);                input.hideSoftInputFromWindow(getWindow().getCurrentFocus()                        .getWindowToken(), 0);            }        }        return handleReturn;    }    protected Rect getLocationOnScreen(EditText mEditText) {        Rect mRect = new Rect();        int[] location = new int[2];        mEditText.getLocationOnScreen(location);        mRect.left = location[0];        mRect.top = location[1];        mRect.right = location[0] + mEditText.getWidth();        mRect.bottom = location[1] + mEditText.getHeight();        return mRect;    }    /**     * This method is called by Spinners onItemSelectedListener.     * When user select an item from the list it is set as text in the IP-address EditText field.     * Selection is then reset to default position, this way it is possible to select same item.     *     * @param dynamicSpinner Spinner     * @param position       int     */    private void selectionMade(Spinner dynamicSpinner, int position) {        if(position !=0 ) {            editIPText.setText(ipAddresses.get(position));            editIPText.requestFocus();            dynamicSpinner.setSelection(0);        }    }    // Calling:/*    Context context = getApplicationContext();    String filename = "log.txt";    String str = read_file(context, filename);*/    public String read_file(Context context, String filename) {        try {            FileInputStream fis = context.openFileInput(filename);            InputStreamReader isr = new InputStreamReader(fis, "UTF-8");            BufferedReader bufferedReader = new BufferedReader(isr);            StringBuilder sb = new StringBuilder();            String line;            int index = 0;            while ((line = bufferedReader.readLine()) != null) {                if (index == 0)                    index++;                else {                    line.trim();                    ipAddresses.add(line);                }            }            return "Successful!";        } catch (FileNotFoundException e) {            return "file not found";        } catch (UnsupportedEncodingException e) {            return "unsupported encoding";        } catch (IOException e) {            return "IO exception";        }    }}