package com.example.anna.colorgame;import android.content.Context;import android.os.Handler;import android.util.Log;import java.io.IOException;import java.io.InterruptedIOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.InetSocketAddress;import java.net.SocketException;import java.net.SocketTimeoutException;/** * This class is a thread that is used in different activities to receive data from server when * needed. DatagramSocket and DatagramPacket are used to receive data. * Depending on data received specific action is taken. */public class ReceiveDataThread implements Runnable {    private static final String TAG = "debugRecieve";    private final Handler handler;    private Context context;    private Player player;    private DatagramSocket mySocket = null;    private boolean isRunning = true;    private ChooseGame ChooseGameClass = null;    private MainMenu MainMenuClass = null;    /**     * This constructor creates new instance of ReceiveDataThread with specified context and     * player object. New Handler object is created using context.     * Context determines which activity thread will be bound to.     *     * @param context Context     * @param player  Player     */    public ReceiveDataThread(Context context, Player player) {        this.player = player;        this.context = context;        handler = new Handler(context.getMainLooper());    }    /**     * This constructor is used in ChooseGame activity. It creates new instance of ReceiveDataThread     * with specified context and player. New Handler object is created using context.     *     * @param context Context     * @param player  Player     */    public ReceiveDataThread(Context context, Player player, ChooseGame thisClass) {        this.player = player;        this.context = context;        handler = new Handler(context.getMainLooper());        this.ChooseGameClass = thisClass;    }    /**     * This constructor is used in MainMenu activity. It creates new instance of ReceiveDataThread     * with specified context and player. New Handler object is created using context.     *     * @param context Context     * @param player  Player     */    public ReceiveDataThread(Context context, Player player, MainMenu thisClass) {        this.player = player;        this.context = context;        handler = new Handler(context.getMainLooper());        this.MainMenuClass = thisClass;    }    /**     * This method is called when thread is started. It contains code that initiates DatagramSocket     * and DatagramPacket to make it possible to wait(in an infinite while loop) for a data from server and do actions     * depending on this data. Created socket is listening to port 4445 by default.     */    @Override    public void run() {        Log.d(TAG, "ReceiveDataThread, run method");        try {            int PORT = 4445;            Log.d(TAG, "Thread. Creating Socket");            mySocket = new DatagramSocket(null);            mySocket.setReuseAddress(true);            mySocket.bind(new InetSocketAddress(PORT));            byte[] receiveData;            DatagramPacket receivePacket;            while (isRunning) {                try {                    Log.d(TAG, "Thread. Initialising byte array and DatagramPacket");                    receiveData = new byte[24];                    receivePacket = new DatagramPacket(receiveData, receiveData.length);                    Log.d(TAG, "Thread. Waiting for message from server");                    mySocket.receive(receivePacket);                    Log.d(TAG, "Thread. Reading DatagramPacket we got from server");                    final String messageFromServer = putCharTogether(receiveData, receiveData.length);                    if (messageFromServer.equals("WIN!")) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Log.d(TAG, "runOnUiThread, run method WIN");                                new GameOver(context, player, "WIN!");                            }                        });                    } else if (messageFromServer.equals("LOSE!")) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Log.d(TAG, "runOnUiThread, run method LOSE");                                new GameOver(context, player, "LOSE!");                            }                        });                    } else if (messageFromServer.equals("logout")) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Log.d(TAG, "runOnUiThread, run method logout");                                new GameOver(context, player, "logout");                            }                        });                    } else if (messageFromServer.equals("start")) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Log.d(TAG, "runOnUiThread, run method start");                                if (context.getClass().getName().contains("MainMenu")) {                                    MainMenuClass.startGame();                                } else if (context.getClass().getName().contains("ChooseGame")) {                                    ChooseGameClass.startGame();                                }                            }                        });                    } else if (messageFromServer.contains("Game")) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Log.d(TAG, "runOnUiThread, run method game");                                MainMenuClass.setNextActivityGame(messageFromServer);                                MainMenuClass.setButtonActive();                            }                        });                    } else if (messageFromServer.contains("choosegame")) {                        runOnUiThread(new Runnable() {                            @Override                            public void run() {                                Log.d(TAG, "runOnUiThread, run method game");                                MainMenuClass.setButtonActive();                            }                        });                    }                } catch (SocketTimeoutException e) {                    Log.d(TAG, "SocketTimeoutException!");                }                Log.d(TAG, "isRunning: " + String.valueOf(isRunning));            }            closeSocket();            Log.d(TAG, "isRunning: " + String.valueOf(isRunning));        } catch (SocketException e) {            e.printStackTrace();        } catch (InterruptedIOException e) {            closeSocket();            Log.d(TAG, "Thread is interrupted, socket closed");        } catch (IOException e) {            Log.e(TAG, e.getMessage());        }    }    /**     * This method is used to sort data received from server to sort away all of the "0".     *     * @param receiveData String     * @param length int     * @return messageFromServer String     */    private String putCharTogether(byte[] receiveData, int length) {        String messageFromServer = "";        for (int i = 0; i < length; i++) {            if (receiveData[i] != 0) {                messageFromServer += (char) receiveData[i];            }        }        return messageFromServer;    }    /**     * This method is used to update main thread.     *     * @param runnable Runnable     */    private void runOnUiThread(Runnable runnable) {        handler.post(runnable);    }    /**     * This method is used to close a socket that is used by the thread.     */    private void closeSocket() {        mySocket.close();    }    /**     * This method sets variable isRunning true or false.     * Setting it false stops while loop inside run method.     * So we can close socket and interrupt thread more safely.     *     * @param isRunning boolean     */    public void setIsRunning(boolean isRunning) {        this.isRunning = isRunning;    }}